#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Gerenciador de Servi√ßos Quality
Controla os 5 servi√ßos espec√≠ficos do sistema Quality
"""

import os
import subprocess
import time
import threading
from typing import Dict, Any, List, Optional
from datetime import datetime

from utils.helpers import get_process_by_name, kill_process_by_pid, validate_path, format_uptime, format_bytes

class QualityServiceManager:
    """Gerenciador espec√≠fico para servi√ßos Quality"""
    
    def __init__(self, config: Dict[str, Any], logger):
        self.config = config
        self.logger = logger
        self.services = config.get('services', [])
        self.dependencies = config.get('service_dependencies', {})
        self.startup_order = config.get('startup_order', [])
        
        # Cache de status
        self.status_cache = {}
        self.cache_lock = threading.Lock()
        
        self.logger.info(f"üîß Service Manager inicializado com {len(self.services)} servi√ßos")
    
    def get_installed_services(self) -> List[Dict[str, Any]]:
        """
        Retorna lista de servi√ßos que est√£o realmente instalados
        
        Returns:
            Lista de servi√ßos instalados
        """
        installed = []
        
        for service in self.services:
            if not service.get('enabled', True):
                continue
                
            executable_path = service.get('executable_path', '')
            
            if validate_path(executable_path):
                installed.append({
                    'name': service['name'],
                    'display_name': service['display_name'],
                    'executable_path': executable_path,
                    'description': service.get('description', ''),
                    'log_base_path': service.get('log_base_path', '')
                })
            else:
                self.logger.warning(f"‚ö†Ô∏è  Servi√ßo {service['display_name']} n√£o encontrado: {executable_path}")
        
        return installed
    
    def get_all_services_status(self) -> Dict[str, Any]:
        """
        Retorna status de todos os servi√ßos
        
        Returns:
            Dicion√°rio com status de cada servi√ßo
        """
        with self.cache_lock:
            status = {}
            
            for service in self.services:
                if not service.get('enabled', True):
                    continue
                    
                service_name = service['name']
                service_status = self._get_service_status(service)
                status[service_name] = service_status
            
            self.status_cache = status
            return status.copy()
    
    def _get_service_status(self, service: Dict[str, Any]) -> Dict[str, Any]:
        """
        Obt√©m status detalhado de um servi√ßo
        
        Args:
            service: Configura√ß√£o do servi√ßo
            
        Returns:
            Status detalhado do servi√ßo
        """
        service_name = service['name']
        display_name = service['display_name']
        executable_path = service.get('executable_path', '')
        
        # Buscar processos do servi√ßo
        processes = get_process_by_name(service_name)
        
        if not processes:
            # Tentar buscar pelo nome do execut√°vel
            exe_name = os.path.basename(executable_path)
            processes = get_process_by_name(exe_name)
        
        if processes:
            # Servi√ßo est√° rodando
            main_process = processes[0]  # Pegar o primeiro processo
            
            return {
                'status': 'running',
                'display_name': display_name,
                'pid': main_process['pid'],
                'name': main_process['name'],
                'exe': main_process['exe'],
                'create_time': main_process['create_time'],
                'uptime': format_uptime(time.time() - main_process['create_time']),
                'memory_usage': format_bytes(main_process['memory_usage']),
                'memory_bytes': main_process['memory_usage'],
                'cpu_percent': main_process['cpu_percent'],
                'process_count': len(processes),
                'last_check': datetime.now().isoformat()
            }
        else:
            # Servi√ßo n√£o est√° rodando
            return {
                'status': 'stopped',
                'display_name': display_name,
                'pid': None,
                'name': None,
                'exe': executable_path,
                'uptime': None,
                'memory_usage': '0 B',
                'memory_bytes': 0,
                'cpu_percent': 0.0,
                'process_count': 0,
                'last_check': datetime.now().isoformat(),
                'error': 'Processo n√£o encontrado'
            }
    
    def start_service(self, service_name: str) -> Dict[str, Any]:
        """
        Inicia um servi√ßo espec√≠fico
        
        Args:
            service_name: Nome do servi√ßo
            
        Returns:
            Resultado da opera√ß√£o
        """
        try:
            service = self._find_service_by_name(service_name)
            if not service:
                return {'success': False, 'error': f'Servi√ßo {service_name} n√£o encontrado'}
            
            executable_path = service.get('executable_path', '')
            if not validate_path(executable_path):
                return {'success': False, 'error': f'Execut√°vel n√£o encontrado: {executable_path}'}
            
            # Verificar se j√° est√° rodando
            current_status = self._get_service_status(service)
            if current_status['status'] == 'running':
                return {'success': True, 'message': f'Servi√ßo {service_name} j√° est√° rodando'}
            
            # Iniciar o servi√ßo
            self.logger.info(f"üöÄ Iniciando servi√ßo: {service['display_name']}")
            
            # Executar o servi√ßo
            process = subprocess.Popen(
                [executable_path],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                cwd=os.path.dirname(executable_path)
            )
            
            # Aguardar um pouco para verificar se iniciou
            time.sleep(2)
            
            # Verificar se iniciou com sucesso
            new_status = self._get_service_status(service)
            if new_status['status'] == 'running':
                self.logger.success(f"‚úÖ Servi√ßo {service['display_name']} iniciado com sucesso")
                return {
                    'success': True,
                    'message': f'Servi√ßo {service_name} iniciado com sucesso',
                    'pid': new_status['pid']
                }
            else:
                return {
                    'success': False,
                    'error': f'Falha ao iniciar servi√ßo {service_name}'
                }
                
        except Exception as e:
            self.logger.error(f"‚ùå Erro ao iniciar servi√ßo {service_name}: {e}")
            return {'success': False, 'error': str(e)}
    
    def stop_service(self, service_name: str) -> Dict[str, Any]:
        """
        Para um servi√ßo espec√≠fico
        
        Args:
            service_name: Nome do servi√ßo
            
        Returns:
            Resultado da opera√ß√£o
        """
        try:
            service = self._find_service_by_name(service_name)
            if not service:
                return {'success': False, 'error': f'Servi√ßo {service_name} n√£o encontrado'}
            
            # Verificar se est√° rodando
            current_status = self._get_service_status(service)
            if current_status['status'] != 'running':
                return {'success': True, 'message': f'Servi√ßo {service_name} j√° est√° parado'}
            
            pid = current_status['pid']
            if not pid:
                return {'success': False, 'error': 'PID do processo n√£o encontrado'}
            
            self.logger.info(f"üõë Parando servi√ßo: {service['display_name']} (PID: {pid})")
            
            # Finalizar o processo
            success = kill_process_by_pid(pid)
            
            if success:
                self.logger.success(f"‚úÖ Servi√ßo {service['display_name']} parado com sucesso")
                return {
                    'success': True,
                    'message': f'Servi√ßo {service_name} parado com sucesso'
                }
            else:
                return {
                    'success': False,
                    'error': f'Falha ao parar servi√ßo {service_name}'
                }
                
        except Exception as e:
            self.logger.error(f"‚ùå Erro ao parar servi√ßo {service_name}: {e}")
            return {'success': False, 'error': str(e)}
    
    def restart_service(self, service_name: str) -> Dict[str, Any]:
        """
        Reinicia um servi√ßo espec√≠fico
        
        Args:
            service_name: Nome do servi√ßo
            
        Returns:
            Resultado da opera√ß√£o
        """
        try:
            self.logger.info(f"üîÑ Reiniciando servi√ßo: {service_name}")
            
            # Parar o servi√ßo
            stop_result = self.stop_service(service_name)
            if not stop_result['success']:
                return stop_result
            
            # Aguardar um pouco
            time.sleep(2)
            
            # Iniciar o servi√ßo
            start_result = self.start_service(service_name)
            if not start_result['success']:
                return start_result
            
            self.logger.success(f"‚úÖ Servi√ßo {service_name} reiniciado com sucesso")
            return {
                'success': True,
                'message': f'Servi√ßo {service_name} reiniciado com sucesso'
            }
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro ao reiniciar servi√ßo {service_name}: {e}")
            return {'success': False, 'error': str(e)}
    
    def restart_all_services(self) -> Dict[str, Any]:
        """
        Reinicia todos os servi√ßos na ordem correta de depend√™ncias
        
        Returns:
            Resultado da opera√ß√£o
        """
        try:
            self.logger.info("üîÑ Reiniciando todos os servi√ßos Quality...")
            
            results = {}
            
            # Parar todos os servi√ßos (ordem inversa)
            stop_order = list(reversed(self.startup_order))
            for service_name in stop_order:
                if self._is_service_enabled(service_name):
                    result = self.stop_service(service_name)
                    results[f'stop_{service_name}'] = result
                    time.sleep(1)
            
            # Aguardar um pouco
            time.sleep(3)
            
            # Iniciar todos os servi√ßos (ordem correta)
            for service_name in self.startup_order:
                if self._is_service_enabled(service_name):
                    result = self.start_service(service_name)
                    results[f'start_{service_name}'] = result
                    time.sleep(2)  # Aguardar entre inicializa√ß√µes
            
            self.logger.success("‚úÖ Todos os servi√ßos Quality reiniciados")
            return {
                'success': True,
                'message': 'Todos os servi√ßos reiniciados',
                'details': results
            }
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro ao reiniciar todos os servi√ßos: {e}")
            return {'success': False, 'error': str(e)}
    
    def _find_service_by_name(self, service_name: str) -> Optional[Dict[str, Any]]:
        """
        Encontra um servi√ßo pelo nome
        
        Args:
            service_name: Nome do servi√ßo
            
        Returns:
            Configura√ß√£o do servi√ßo ou None
        """
        for service in self.services:
            if service['name'] == service_name:
                return service
        return None
    
    def _is_service_enabled(self, service_name: str) -> bool:
        """
        Verifica se um servi√ßo est√° habilitado
        
        Args:
            service_name: Nome do servi√ßo
            
        Returns:
            True se o servi√ßo est√° habilitado
        """
        service = self._find_service_by_name(service_name)
        return service and service.get('enabled', True)
    
    def get_service_dependencies(self, service_name: str) -> List[str]:
        """
        Retorna depend√™ncias de um servi√ßo
        
        Args:
            service_name: Nome do servi√ßo
            
        Returns:
            Lista de depend√™ncias
        """
        return self.dependencies.get(service_name, [])
    
    def check_dependencies(self, service_name: str) -> Dict[str, Any]:
        """
        Verifica se as depend√™ncias de um servi√ßo est√£o atendidas
        
        Args:
            service_name: Nome do servi√ßo
            
        Returns:
            Status das depend√™ncias
        """
        dependencies = self.get_service_dependencies(service_name)
        status = {}
        
        for dep in dependencies:
            dep_status = self._get_service_status(self._find_service_by_name(dep))
            status[dep] = dep_status['status'] == 'running'
        
        return {
            'service': service_name,
            'dependencies': status,
            'all_satisfied': all(status.values())
        }
